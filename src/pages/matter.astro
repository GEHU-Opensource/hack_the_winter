---

---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Matter.js Example</title>
		<style>
			body,
			html {
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
			#matter-container {
				width: 100%;
				height: 100lvh;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div id="matter-container"></div>
	</body>

	<script>
		const container = document.getElementById(
			"matter-container",
		) as HTMLDivElement;

		import {
			Engine,
			Render,
			Runner,
			Composites,
			Common,
			MouseConstraint,
			Mouse,
			Composite,
			Bodies,
		} from "matter-js";

		// create engine
		const engine = Engine.create();
		const world = engine.world;

		// create renderer
		const render = Render.create({
			element: container,
			engine: engine,
			options: {
				width: container.clientWidth,
				height: container.clientHeight,
				background: "transparent",
				wireframes: false,
				showAngleIndicator: false,
				// pixelRatio: window.devicePixelRatio,
			},
		});

		const stack = Composites.stack(
			20,
			20,
			10,
			5,
			0,
			0,
			(x: number, y: number) => {
				const radius = Common.random(12, 40);
				return Bodies.circle(x, y, radius);
			},
		);

		const thickness = 60;

		// make bodies reassignable so we can recreate them on resize
		let ground = Bodies.rectangle(
			container.clientWidth / 2,
			container.clientHeight + thickness / 2,
			container.clientWidth,
			thickness,
			{ isStatic: true },
		);

		let leftWall = Bodies.rectangle(
			-thickness / 2,
			container.clientHeight / 2,
			thickness,
			container.clientHeight * 5,
			{ isStatic: true },
		);

		let rightWall = Bodies.rectangle(
			container.clientWidth + thickness / 2,
			container.clientHeight / 2,
			thickness,
			container.clientHeight * 5,
			{ isStatic: true },
		);

		let ceiling = Bodies.rectangle(
			container.clientWidth / 2,
			-thickness / 2,
			container.clientWidth,
			thickness,
			{ isStatic: true },
		);

		Composite.add(world, [ground, leftWall, rightWall, ceiling, stack]);

		// add mouse control
		const mouse = Mouse.create(render.canvas);
		const mouseConstraint = MouseConstraint.create(engine, {
			mouse: mouse,
			constraint: {
				stiffness: 0.2,
				render: {
					visible: false,
				},
			},
		});

		Composite.add(world, mouseConstraint);

		// keep the mouse in sync with rendering
		render.mouse = mouse;

		mouseConstraint.mouse.element.removeEventListener(
			"mousewheel",
			mouseConstraint.mouse.mousewheel,
		);

		mouseConstraint.mouse.element.removeEventListener(
			"DOMMouseScroll",
			mouseConstraint.mouse.mousewheel,
		);

		Render.run(render);

		// create runner
		const runner = Runner.create();
		Runner.run(runner, engine);

		function handleResize(container: HTMLDivElement) {
			const width = container.clientWidth;
			const height = container.clientHeight;

			// update renderer canvas size
			render.canvas.width = width;
			render.canvas.height = height;

			if (render.options) {
				render.options.width = width;
				render.options.height = height;
			}

			// remove old static bounds (if they exist) and recreate them sized to new container
			try {
				if (ground) Composite.remove(world, ground);
				if (leftWall) Composite.remove(world, leftWall);
				if (rightWall) Composite.remove(world, rightWall);
				if (ceiling) Composite.remove(world, ceiling);
			} catch (e) {
				// ignore removal errors (body might already be removed)
			}

			ground = Bodies.rectangle(
				width / 2,
				height + thickness / 2,
				width,
				thickness,
				{ isStatic: true },
			);
			leftWall = Bodies.rectangle(
				-thickness / 2,
				height / 2,
				thickness,
				height * 5,
				{ isStatic: true },
			);
			rightWall = Bodies.rectangle(
				width + thickness / 2,
				height / 2,
				thickness,
				height * 5,
				{ isStatic: true },
			);
			ceiling = Bodies.rectangle(
				width / 2,
				-thickness / 2,
				width,
				thickness,
				{ isStatic: true },
			);

			Composite.add(world, [ground, leftWall, rightWall]);

			// ensure mouse/render references remain correct
			render.mouse = mouse;
		}

		// call once to ensure bodies match initial canvas size and on any load-resize
		handleResize(container);

		window.addEventListener("resize", () => {
			handleResize(container);
		});
	</script>
</html>
